
МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


Кафедра «Програмної інженерії»




ЗВІТ

З Лабораторної роботи № 2

з дисципліни

«Аналіз та рефакторинг коду»









Виконав 										 Перевірив
ст. гр. ПЗПІ-22-7								 ст. викладач каф. ПІ
Дудуков Олександр 								Сокорчук І. П.












Харків 2024
1 Вступ

1.1	Тема

Розробка бази даних для серверної частини програмної системи та прикладного програмного інтерфейсу (АРІ).

1.2	Мета

Розробити базу даних для серверної частини програмної системи та прикладного програмного інтерфейсу.


2 Розробка діаграм

2.1 Розробка UML-діаграми прецедентів для серверної частини системи


Для UML-діаграми прецедентів були обрані два основних актори: користувач (User) та адміністратор (Admin). Користувач може реєструватися у системі, авторизуватися для доступу до функціоналу, отримувати сповіщення про зміни в умовах робочого середовища (температура, вологість, рівень CO₂), переглядати візуалізовані дані у вигляді графіків і звітів, спілкуватися з іншими користувачами через вбудований месенджер. Адміністратор може виконувати всі дії користувача, управляти даними про умови середовища (CRUD-операції: створення, читання, оновлення, видалення), керувати даними користувачів системи.
 На основі цих акторів і прецедентів розробимо UML-діаграму прецедентів (див. рис. 2.1)
 

                                     Рис. 2.1 – UML діаграма прецедентів

2.2 Розробка ER діаграми даних

Для розробки бази даних створено такі таблиці: User (Користувач), Location (Локація), Sensor (Сенсор), Message (Повідомлення), Notification (Сповіщення), Admin (Адміністратор) (див. рис. 2.2).

 
Рис. 2.2 – ER діаграма даних
3. Розробка бази даних


3.1 Розроблення бази даних програмної системи
Код наведено у додатку А

Розробка бази даних для програмної системи здійснюється з урахуванням вимог щодо зберігання та обробки даних про користувачів, локації, сенсори, повідомлення, сповіщення та адміністраторів системи. Для цієї мети вибрано рішення на основі реляційної бази даних, що забезпечує збереження зв'язків між сутностями, зручне управління даними та високу ефективність у запитах.
Структура бази даних складається з наступних основних таблиць:

3.1.1 Таблиця users:
Таблиця містить дані про користувачів системи, що можуть бути співробітниками або адміністраторами. Кожен запис у таблиці представляє інформацію про користувача, таку як ім'я, прізвище, електронна пошта, роль користувача (співробітник або адміністратор), телефон та локація, де працює користувач.
3.1.2 Таблиця locations:
Ця таблиця зберігає інформацію про локації, які можуть бути лабораторіями, офісами чи полігонами. Кожен запис у таблиці містить дані про тип локації, її назву, місткість, статус, температуру, вологість та рівень CO₂, що важливо для моніторингу умов на робочих місцях.
3.1.3 Таблиця sensors:
Таблиця зберігає дані про IoT-сенсори, встановлені в локаціях для моніторингу умов (температура, вологість, CO₂). Кожен сенсор має унікальний ідентифікатор, тип, статус і прив'язку до локації, де він встановлений.
3.1.4 Таблиця messages:
Таблиця зберігає повідомлення, які обмінюються між користувачами через месенджер. Кожен запис містить ідентифікатори відправника і отримувача, текст повідомлення та час його відправлення.
3.1.5 Таблиця notifications:
Таблиця зберігає сповіщення для користувачів. Сповіщення можуть бути надіслані через різні події, такі як зміни умов на локаціях або нові повідомлення від колег. Кожен запис містить ідентифікатор користувача, текст сповіщення та час створення.
3.1.6 Таблиця admins:
Таблиця зберігає дані про адміністраторів системи. Кожен запис містить ідентифікатор адміністратора, ім'я, прізвище, електронну пошту та час створення облікового запису.
3.2 Зв'язки між таблицями
Всі таблиці містять зовнішні ключі для зберігання зв'язків між даними. Це дозволяє ефективно зберігати й обробляти інформацію про користувачів, локації, сенсори та інші сутності. Ось основні зв'язки:
•	Таблиця users зв'язана з таблицею locations через поле location_id, що визначає місце роботи користувача.
•	Таблиця sensors зв'язана з таблицею locations через поле location_id, оскільки кожен сенсор встановлений в певній локації.
•	Таблиця messages зв'язана з таблицею users через поля sender_id та receiver_id, що вказують на відправника та отримувача повідомлень.
•	Таблиця notifications зв'язана з таблицею users через поле user_id, оскільки кожне сповіщення надсилається конкретному користувачу.
•	Таблиця admins не має прямих зв'язків з іншими таблицями, однак адміністратори мають доступ до керування користувачами, локаціями та сенсорами.
3.3 Використання ORM для роботи з базою даних
Для роботи з базою даних буде використовуватися ORM (Object-Relational Mapping), який спрощує створення моделей, валідацію даних та взаємодію з реляційною базою даних. ORM забезпечить простоту в управлінні зв'язками між таблицями, а також дозволить ефективно виконувати запити для отримання потрібних даних.
Таке проектування бази даних дозволяє зберігати і обробляти дані з високою ефективністю, забезпечує підтримку масштабованості системи в майбутньому та дозволяє зручно працювати з даними через зв'язки між сутностями.

Після створення бази даних, була розроблена діаграма структури бази даних (див. рис. 3.1).
 Рис. 3.1 – діаграма структури бази даних

4 Розробка серверної частини
4.2 Розробка АРІ для взаємодії серверної частини з клієнтами
Для реалізації серверної частини програмної системи було розроблено наступні маршрути та контролери, що забезпечують функціонал реєстрації користувачів, авторизації, активації акаунтів, а також управління сесіями користувачів. Крім того, передбачено можливість отримання даних про користувачів, локації, сенсори та сповіщення.
4.2.1 Маршрути:
• POST /register – маршрут для реєстрації нового користувача.
• POST /login – маршрут для авторизації користувача.
• POST /logout – маршрут для виходу користувача із системи.
• GET /activate/:link – маршрут для активації акаунта через посилання активації, яке надсилається на email користувача після реєстрації.
• GET /refresh – маршрут для оновлення сесії за допомогою refresh токену.
• GET /users – маршрут для отримання списку всіх користувачів (доступний тільки для авторизованих адміністраторами користувачів).
• GET /locations – маршрут для отримання інформації про локації (доступний для авторизованих користувачів).
• GET /sensors – маршрут для отримання інформації про сенсори в системі.
• GET /notifications – маршрут для отримання сповіщень для конкретного користувача.
4.2.2 Контролери:
UserController:
•	register: Реєстрація нового користувача. Включає в себе валідацію введених даних, створення акаунта в базі даних та надсилання активаційного посилання на email користувача. Після реєстрації генерується refresh токен, який зберігається в cookie.
•	login: Авторизація користувача. Перевірка введених даних на відповідність даним, збереженим у базі даних. У разі успішної авторизації генерується refresh токен.
•	logout: Вихід користувача з системи. Видалення refresh токену з cookies для завершення сесії користувача.
•	activate: Активація користувача за допомогою посилання, яке надається після реєстрації.
•	refresh: Оновлення токенів користувача, що дозволяє підтримувати сесію без необхідності повторної авторизації.
•	getUsers: Отримання списку всіх користувачів системи для адміністратора. Доступний тільки для авторизованих адміністраторів.
LocationController:
•	getLocations: Отримання даних про локації (офіси, лабораторії, полігони) для користувачів, що мають відповідні права доступу.
SensorController:
•	getSensors: Отримання даних про IoT-сенсори, що встановлені в локаціях. Інформація про сенсори включає тип, статус та локацію, де вони встановлені.
NotificationController:
•	getNotifications: Отримання сповіщень для конкретного користувача, що включають важливі оновлення про зміни умов на локаціях, нові повідомлення або інші важливі події в системі.
4.2.3 Код реалізації:
Це забезпечить базову функціональність для реєстрації та авторизації користувачів, активації акаунтів, оновлення сесії, а також отримання даних про локації, сенсори та сповіщення.
Цей набір маршрутів і контролерів гарантує безпечну взаємодію клієнтів із серверною частиною програми, а також ефективне управління сесіями та даними в рамках вашої системи. Завдяки створеному АРІ, було розроблено програмну реалізацію, яка інтегрується з базою даних та забезпечує доступ до актуальної інформації для користувачів та адміністраторів системи (див. рис. 4.1).
 
Рис. 4.1 – програмна реалізація для АРІ

 						5  Висновок
У рамках виконання лабораторної роботи була розроблена програмна система для моніторингу умов робочих приміщень. Спочатку створено UML діаграму прецедентів і ER діаграму даних, які визначають основні процеси взаємодії користувачів і системи. На їх основі спроектовано базу даних для зберігання інформації про користувачів, локації, сенсори та повідомлення.
Також розроблено API для взаємодії серверної частини з клієнтами, яке включає функції реєстрації, авторизації, активації акаунтів і управління сесіями користувачів. У результаті була створена ефективна система для моніторингу робочих умов і комунікації з користувачами через мобільні та веб-інтерфейси.
Посилання на відео:
						Додаток А

1. const express = require('express');
2. const mongoose = require('mongoose');
3. 
4. // Підключення до MongoDB
5. const uri = 'mongodb+srv://konopqgg:ueTTeJnb2nV0x12M@cluster1.oh9qd.mongodb.net/?retryWrites=true&w=majority&appName=Cluster1';
6. 
7. mongoose.connect(uri, { useNewUrlParser: true, useUnifiedTopology: true })
8.   .then(() => {
9.     console.log('Connected to MongoDB');
10.   })
11.   .catch((err) => {
12.     console.error('Failed to connect to MongoDB', err);
13.   });
14. 
15. // Створення схем і моделей
16. 
17. // User Schema
18. const userSchema = new mongoose.Schema({
19.   first_name: { type: String, required: true },
20.   last_name: { type: String, required: true },
21.   email: { type: String, required: true, unique: true },
22.   role: { type: String, enum: ['Employee', 'Administrator'], required: true },
23.   phone: String,
24.   location_id: { type: mongoose.Schema.Types.ObjectId, ref: 'Location' }
25. });
26. const User = mongoose.model('User', userSchema);
27. 
28. // Location Schema
29. const locationSchema = new mongoose.Schema({
30.   type: { type: String, enum: ['Laboratory', 'Office', 'Polygon'], required: true },
31.   name: { type: String, required: true },
32.   capacity: Number,
33.   status: { type: String, enum: ['Free', 'Occupied'], required: true },
34.   temperature: Number,
35.   humidity: Number,
36.   co2_level: Number
37. });
38. const Location = mongoose.model('Location', locationSchema);
39. 
40. // Sensor Schema
41. const sensorSchema = new mongoose.Schema({
42.   type: { type: String, enum: ['Temperature', 'Humidity', 'CO2'], required: true },
43.   location_id: { type: mongoose.Schema.Types.ObjectId, ref: 'Location', required: true },
44.   status: { type: String, enum: ['Active', 'Inactive'], required: true }
45. });
46. const Sensor = mongoose.model('Sensor', sensorSchema);
47. 
48. // Message Schema
49. const messageSchema = new mongoose.Schema({
50.   sender_id: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
51.   receiver_id: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
52.   message_text: String,
53.   timestamp: { type: Date, default: Date.now }
54. });
55. const Message = mongoose.model('Message', messageSchema);
56. 
57. // Notification Schema
58. const notificationSchema = new mongoose.Schema({
59.   user_id: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
60.   notification_text: String,
61.   timestamp: { type: Date, default: Date.now }
62. });
63. const Notification = mongoose.model('Notification', notificationSchema);
64. 
65. // Admin Schema
66. const adminSchema = new mongoose.Schema({
67.   first_name: { type: String, required: true },
68.   last_name: { type: String, required: true },
69.   email: { type: String, required: true, unique: true },
70.   timestamp: { type: Date, default: Date.now }
71. });
72. const Admin = mongoose.model('Admin', adminSchema);
73. 
74. // Express Application
75. const app = express();
76. app.use(express.json());
