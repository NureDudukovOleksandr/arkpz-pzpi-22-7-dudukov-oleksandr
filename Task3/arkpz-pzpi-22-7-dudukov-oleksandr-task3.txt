Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Кафедра програмної інженерії

Звіт
З лабораторної роботи №3
З дисципліни «Аналіз та рефакторинг коду»
на тему: «РОЗРОБКА БІЗНЕС-ЛОГІКИ ТА ФУНКЦІЙ АДМІНІСТРУВАННЯ СЕРВЕРНОЇ ЧАСТИНИ ПРОГРАМНОЇ СИСТЕМИ »





Виконавець:		
ст. гр. ПЗПІ-22-2						                    Дудуков Олександр

Перевірив:		
ст. викладач кафедри ПІ				                    Сокорчук І. П. 
	


                                                                                                       








Харків 2024
1 МЕТА РОБОТИ

Метою роботи є розробка  бізнес-логіки та функцій адміністрування для серверної частини програмної системи.


2 ХІД РОБОТИ
В ході виконання лабораторної роботи було впроваджено низку функцій, які охоплюють основні аспекти адміністрування, безпеки, аналізу даних та моніторингу умов робочих середовищ. Опис інженерних рішень включає:
	Зміна паролю: Система передбачає можливість зміни пароля для користувачів при умові, що вони аутентифіковані. У разі забутого паролю, система надсилає новий пароль на вказану електронну пошту користувача.
	Захист даних користувачів: Для забезпечення безпеки даних користувачів, паролі зберігаються в зашифрованому вигляді за допомогою модуля bcrypt. Це гарантує, що паролі не будуть збережені в простому тексті.
	Авторизація та сесії: Система авторизації реалізована за допомогою JWT (JSON Web Token). Кожен користувач отримує токен при успішній авторизації, що дозволяє працювати із системою без необхідності повторно вводити пароль.
	Ролі користувачів: Кожному користувачеві надається роль, яка визначає рівень доступу до функціоналу системи. Наприклад, користувач може мати роль «Співробітник» для перегляду даних про умови робочих приміщень, або роль «Адміністратор» для виконання CRUD-операцій на даними локацій, сенсорів та користувачів.
	Сповіщення для користувачів: Система надає сповіщення користувачам при зміні умов робочого середовища, таких як зміни температури, вологості чи рівня CO₂ в приміщеннях. Крім того, користувачі отримують сповіщення про важливі події через вбудований месенджер.
	Модуль аналізу даних: Одна з ключових функцій системи полягає в зборі та аналізі даних, пов'язаних із умовами робочих середовищ та роботою IoT-сенсорів:
	Аналіз середніх показників: Система обчислює середні показники для температури, вологості та рівня CO₂ в локаціях на основі даних з сенсорів. Це дозволяє визначити загальний стан середовища в приміщеннях.
	Обчислення змін: Система автоматично порівнює зміни в умовах середовища за певні періоди (наприклад, рік до року), надаючи відсоткові зміни для кожного сенсора.
	Топ-локації за умовами: Оцінка локацій, де умови робочого середовища найбільш сприятливі для співробітників. Це може включати топ-5 локацій з найкращими середніми показниками температури або вологості.
	Функціонал адміністрування: Адміністратори мають доступ до розширених функцій управління системою:
	Управління користувачами: Адміністратори можуть створювати, редагувати або видаляти користувачів. Крім того, є можливість блокувати користувачів або відновлювати їх доступ.
	Управління сенсорами та локаціями: Адміністратори можуть додавати нові локації та сенсори, змінювати їх налаштування та виявляти неполадки в роботі сенсорів.
	Зміна умов робочого середовища: Якщо рівень CO₂ перевищує безпечний рівень, система автоматично надсилає сповіщення користувачам та адміністраторам. Крім того, користувачі можуть налаштовувати свої повідомлення про зміни в умовах на основі своїх інтересів.
	Аналіз сенсорів: Для кожного сенсора, що працює в системі, адміністратори можуть переглядати статистику (середні значення, зміну показників, аварійні ситуації) та отримувати рекомендації щодо технічного обслуговування.
	Модуль аналізу даних: Для кожного користувача (наприклад, для співробітників або адміністраторів) розроблено аналітичний модуль, що дозволяє здійснювати прогнози щодо покращення умов у приміщеннях на основі історичних даних.

3 ВИСНОВКИ
Під час виконання лабораторної роботи було досягнуто значного прогресу в розробці програмної системи для моніторингу умов робочих середовищ та управління IoT-сенсорами. Реалізовані функціональні можливості охоплюють ключові аспекти безпеки, адміністрування та аналітики даних, що значно покращує ефективність роботи користувачів та підвищує надійність системи.
Забезпечення безпеки даних користувачів реалізовано шляхом шифрування паролів за допомогою модуля bcrypt, що гарантує високий рівень захисту особистої інформації. Механізми зміни та скидання паролю дозволяють користувачам швидко відновити доступ до своїх облікових записів, що підвищує зручність користування системою.
Використання JWT токенів для авторизації забезпечує надійний та безпечний доступ до системи, в той час як ролі користувачів дають змогу ефективно керувати доступом до різних функцій системи, підвищуючи її масштабованість та безпеку.
Система нотифікацій покращує взаємодію з користувачами, надаючи своєчасну інформацію про зміни в умовах робочих середовищ, таких як підвищення рівня CO₂ або температури, а також повідомляючи про критичні стани в приміщеннях. Це дозволяє швидко реагувати на потенційно небезпечні ситуації, забезпечуючи безпеку співробітників.
Розширення функціоналу адміністрування дозволяє адміністраторам ефективно управляти користувачами та сенсорами. Адміністратори можуть додавати нові сенсори, налаштовувати їх параметри, а також блокувати доступ користувачів у разі порушень. Це сприяє кращому контролю над системою та підвищенню її стабільності.
Інструменти аналітики дозволяють здійснювати детальний моніторинг та аналіз даних з IoT-сенсорів, що допомагає оптимізувати умови робочих середовищ. Аналіз середніх значень температури, вологості та рівня CO₂ дає змогу приймати обґрунтовані рішення щодо покращення умов роботи та забезпечення комфорту співробітників.
Реалізовані функції та аналітичні інструменти підвищують ефективність роботи системи та сприяють оптимізації бізнес-процесів, що має важливе значення для підтримки високого рівня безпеки та комфорту на робочих місцях.
ДОДАТОК А
UML діаграма діяльності

Рисунок А.1 – Надсилання сповіщення 

Рисунок А.2 – Перевірка на задовільність середовища 
 
Рисунок А.3 – Панель адміністратора 
















Додаток Б
Фрагмент програмного коду надсилання сповіщення
1. const express = require('express');
2. const Notification = require('../models/notification.model'); 
3. const User = require('../models/user.model'); 
4. const router = express.Router();
5. 
6. 
7. router.get('/', async (req, res) => {
8.   try {
9.     const notifications = await Notification.find(); 
10.     res.status(200).json(notifications);
11.   } catch (error) {
12.     res.status(500).json({ message: error.message });
13.   }
14. });
15. 
16. 
17. router.post('/', async (req, res) => {
18.   const { notification_text } = req.body;
19. 
20.   if (!notification_text) {
21.     return res.status(400).json({ message: 'Текст сповіщення обов\'язковий' });
22.   }
23. 
24.   try {
25.     
26.     const users = await User.find(); 
27. 
28.    
29.     const notifications = await Promise.all(users.map(async (user) => {
30.       const notification = new Notification({
31.         user_id: user._id,
32.         notification_text,
33.         timestamp: new Date(),
34.       });
35. 
36.       
37.       await notification.save();
38.       return notification;
39.     }));
40. 
41.     res.status(201).json({
42.       message: 'Сповіщення успішно надіслано всім користувачам',
43.       notifications,
44.     });
45.   } catch (error) {
46.     res.status(500).json({ message: error.message });
47.   }
48. });
49. 
50. module.exports = router;
51.


Фрагмент програмного  перевірка на задовільність середовища
1. const express = require('express');
2. const Location = require('../models/location.model');
3. const Notification = require('../models/notification.model');
4. const router = express.Router();
5. 
6. 
7. const temperatureThreshold = { min: 18, max: 24 };
8. const humidityThreshold = { min: 30, max: 60 };
9. const co2Threshold = { max: 1000 };
10. 
11. 
12. const createNotification = async (locationName, alertMessage) => {
13.   const notification = new Notification({
14.     notification_text: `Попередження для локації ${locationName}: ${alertMessage}`,
15.   });
16.   await notification.save();
17.   return notification;
18. };
19. 
20. 
21. router.post('/', async (req, res) => {
22.   const { location_id } = req.body;
23. 
24.   if (!location_id) {
25.     return res.status(400).json({ message: 'Потрібно вказати location_id.' });
26.   }
27. 
28.   try {
29.     
30.     const location = await Location.findById(location_id);
31.     if (!location) {
32.       return res.status(404).json({ message: 'Локацію не знайдено.' });
33.     }
34. 
35.     const { temperature, humidity, co2_level, name } = location;
36.     let alertMessage = '';
37.     let isAlert = false;
38. 
39.     
40.     if (temperature < temperatureThreshold.min || temperature > temperatureThreshold.max) {
41.       alertMessage += `Температура виходить за допустимі межі. Поточна: ${temperature}°C. `;
42.       isAlert = true;
43.     }
44. 
45.     
46.     if (humidity < humidityThreshold.min || humidity > humidityThreshold.max) {
47.       alertMessage += `Вологість виходить за допустимі межі. Поточна: ${humidity}%. `;
48.       isAlert = true;
49.     }
50. 
51.     
52.     if (co2_level > co2Threshold.max) {
53.       alertMessage += `Рівень CO2 занадто високий. Поточний: ${co2_level} ppm. `;
54.       isAlert = true;
55.     }
56. 
57.     
58.     if (isAlert) {
59.       const notification = await createNotification(name, alertMessage);
60. 
61.       return res.status(200).json({
62.         message: 'Умови локації перевірено, сповіщення надіслано.',
63.         notification: notification,
64.       });
65.     } else {
66.       return res.status(200).json({
67.         message: 'Умови локації знаходяться в межах допустимих значень.',
68.       });
69.     }
70.   } catch (error) {
71.     console.error(error);
72.     res.status(500).json({ message: 'Помилка під час перевірки умов локації.', error: error.message });
73.   }
74. });
75. 
76. module.exports = router;



